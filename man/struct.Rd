% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/struct.R
\name{struct}
\alias{struct}
\title{Simple structures}
\usage{
struct(x, class, ...)
}
\arguments{
\item{x}{A list of data}

\item{class}{A vector of classes}

\item{...}{Additional attributes; named}
}
\value{
An object with class defined as \code{class} and attributes \code{...}
}
\description{
Create simple structures
}
\details{
Unlike \code{\link[base:structure]{base::structure()}} this does not provide additional checks
for special names, performs no \code{\link[base:mode]{base::storage.mode()}} conversions for
\code{factors} (\code{x} therefor has to be an \code{integer}), \code{attributes} from \code{x} are
not retained, and \code{class} is specified outside of other attributes and
assigned after \code{\link[base:attributes]{base::attributes()}} is called.

Essentially, this is just a wrapper for calling \code{\link[base:attributes]{base::attributes()}} then
\code{\link[base:class]{base::class()}}.
}
\examples{
x <- list(a = 1, b = 2)
# structure() retains the $names attribute of x but struct() does not
structure(x, class = "data.frame", row.names = 1L)
struct(x, "data.frame", row.names = 1L)
struct(x, "data.frame", row.names = 1L, names = names(x))

# structure() corrects entries for "factor" class
# but struct() demands the data to be an integer
structure(1, class = "factor", levels = "a")
try(struct(1, "factor", levels = "a"))
struct(1L, "factor", levels = "a")

# Due to the use of class() to assign class, you may experience some
# other differences between structure() and struct()
x <- structure(1, class = "integer")
y <- struct(1, "integer")
str(x)
str(y)

if (package_available("waldo")) {
  waldo::compare(x, y, x_arg = "structure", y_arg = "struct")
} else {
  all.equal(x, y)
}
}
