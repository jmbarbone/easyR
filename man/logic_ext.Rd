% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/logic.R
\name{logic_ext}
\alias{logic_ext}
\alias{is_true}
\alias{is_false}
\alias{\%or\%}
\alias{OR}
\alias{AND}
\alias{either}
\alias{is_boolean}
\title{Logic - Extension'}
\usage{
is_true(x)

is_false(x)

x \%or\% y

OR(..., na.rm = FALSE)

AND(..., na.rm = FALSE)

either(x, y)

is_boolean(x)
}
\arguments{
\item{x, y}{A vector of logical values.  If `NULL` will generate a warning.  If
not a logical value, will return `NA` equal to the vector length}

\item{...}{Vectors or a list of logical values}

\item{na.rm}{Logical, if `TRUE` will ignore `NA`}
}
\description{
All functions take logical or logical-like (i.e., 1, 0, or NA as integer or
  doubles) and return logical values.

Extensions to the base logical operations to account for `NA` values.

[base::isTRUE()] and b[ase::isFALSE()] will only return single length `TRUE`
  or `FALSE` as it checks for valid lengths in the evaluation.  When needing
  to check over a vector for the presense of `TRUE` or `FALSE` and not being
  held back by `NA` values, `is_true` and `is_false` will always provide a
  `TRUE` `FALSE` when the vector is logical or return `NA` is the vector `x`
  is not logical.

`%or%` is just a wrapper for [base::xor()]
}
\details{
Logical operations, extended
}
\examples{

x <- c(TRUE, FALSE, NA)
y <- c(FALSE, FALSE, TRUE)
z <- c(TRUE, NA, TRUE)
isTRUE(x)
is_true(x)
isFALSE(x)
is_false(x)
TRUE \%or\% FALSE
NA \%or\% FALSE
OR(x, y, z)
OR(x, y, z, na.rm = TRUE)
AND(x, y, z)
AND(x, y, z, na.rm = TRUE)
either(TRUE, FALSE)
either(FALSE, NA)
either(TRUE, NA)
is_boolean(x)
is_boolean(c(1L, NA_integer_, 0L))
is_boolean(c(1.01, 0, -1))
}
